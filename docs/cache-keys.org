Cache keys

Which cache keys are used, and what do they mean?

* Notes on the implementation
  This new implementation doesn't take into account that relationships may be defined bidirectionally.  The caching mechanism should cope with this in the future, but doesn't do so at this stage.  Such a thing can be bolted on top of the current approach, by introspecting the defined model and altering the cache primitives.  The current primitives should be sufficient.

* Why cache keys
  The cache keys ensure that the mu-cache can cache resources, and that the mu-cache can clear the resources when they are altered.  The meaning of each of the cache keys needs to be well-defined, and the combination of all keys needs to allow us to correctly reset the cache.

* TODO Which cache keys
  An overview of each of the cache keys, and when you should use them.

  - { resource, id } :: DEPRECATED Clear whenever this specific resource changes
  - { uri } :: Replacement for { resource, id }
  - { resource } :: Clear whenever a listing of this resource could have changed
  - { resource, id, relationship } :: DEPRECATED Clear whenever the
       relationship for this specific resource gets updated. Note that
       including this likely means including { resource, id } of the
       target of the relationship also.
  - { uri, relationship } :: Replacement for { resource, id, relationship }

* What should happen on each call

** DONE list-call
   - { resource } :: for simple list calls

** TODO show-call
   - { resource, id } :: DEPRECATED for the specific resource
   - { uri } :: Replacement for { resource, id }

** TODO show-relation-call
   - { resource, id, relationship } :: DEPRECATED cache only
        invalidates when relationships are altered, or resources
        themselves.
   - { uri , relationship } :: Replacement for { resource, id, relationship }
   - { resource, relationship } :: used for clearing inverse
        relationships.  in this case we will not know which links to
        clear exactly.
   - { resource, id } :: DEPRECATED for each returned resource
   - { uri } :: Replacement for { resource, id }

*** DONE What about pagination?
    Check if the type of resource shouldn't be paginated.  If it
    should be, then cache on { returnedResource }, otherwise cache on
    the specific returned resources.

** DONE create-call
   - { resource } :: b/c lists can be altered

*** TODO relationships
    When inverse relationships can be checked, this should also output
    the relationships.

** TODO update-call
   - { resource } :: for each touched class
   - { resource, id } :: DEPRECATED for attributes
   - { uri } :: Replacement for { resource, id }
   - { resource, id, relationship } :: DEPRECATED for altered relationships
   - { uri, relationship } :: Replacement for { resource, id, relationship }
   - { resource, relationship } :: for known inverse relationships

** TODO delete-call
   - { resource } :: b/c lists can be altered
   - { resource, id } :: DEPRECATED for the deleted object
   - { uri } :: Replacement for { resource, id }
   - --{ resource, relationship }-- :: not needed, either our
        identifier is specified in the other direction, or we do not
        exist anymore.

** TODO patch-relation-call
   - { resource } :: may have an effect on listings (filters, for instance)
   - { resource, id, relationship } :: DEPRECATED invalidate cached relationship
   - { uri, relationship } :: Replacement for { resource, id, relationship }
   - { resource, relationship } :: for known inverse relationships

** TODO add-relation-coll
   - { resource } :: see patch-relation-call
   - { resource, id, relationship } :: DEPRECATED see patch-relation-call
   - { uri, relationship } :: Replacement for { resource, id, relationship }
   - { resource, relationship } :: see patch-relation-call

** TODO delete-relation-call
   - { resource } :: see patch-relation-call
   - { resource, id, relationship } :: DEPRECATED  see patch-relation-call
   - { uri, relationship } :: Replacement for { resource, id, relationship }
   - { resource, relationship } :: see patch-relation-call

** DONE included resources
   Included resources can be specified by their relationship.  In
   unconstrained lists, we specify the connected resource, in
   constrained lists, we specify the resource itself.

*** TODO constrained lists
    - { targetResource, id } :: DEPRECATED Pick included destination elements
    - { uri } :: Replacement for { targetResource, id }
    - { resource, id, relationship } :: DEPRECATED Pick the relationship of the
         item which has the inclusion.
    - { uri, relationship } :: Replacement for { resource, id, relationship }
    - { resource, relationship } :: Specify the relationship itself,
         for clearing known inverse relationships

*** unconstrained lists
    - { targetResource } :: If there's no specific set of items to
         start from, the whole targetResource can invalidate the
         cache.
